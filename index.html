<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kinematics Vector Lab</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- TensorFlow.js and Coco-SSD -->
    <!-- Using 3.18.0 (Stable) and Coco-SSD 2.2.2 -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js" onerror="handleScriptError('TFJS')"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js" onerror="handleScriptError('Coco-SSD')"></script>

    <style>
        body {
            overscroll-behavior: none;
            touch-action: none;
            background-color: #1a1a1a;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        /* Container ensures video and canvas overlap perfectly */
        #camera-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        /* Loading Overlay */
        #loader {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 20px;
            text-align: center;
        }

        /* Floating UI Panel */
        #ui-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 1.5rem;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 40;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #3b82f6;
            margin-top: -10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #4b5563;
            border-radius: 2px;
        }

        /* Debug Console */
        #debug-console {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100px;
            background: rgba(0,0,0,0.5);
            color: lime;
            font-family: monospace;
            font-size: 10px;
            overflow-y: scroll;
            z-index: 100;
            pointer-events: none;
            display: none; /* Hidden by default unless error */
        }
    </style>
</head>
<body>

    <!-- Debug Console -->
    <div id="debug-console"></div>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mb-4"></div>
        <h2 class="text-xl font-bold" id="status-title">System Check...</h2>
        <p class="text-gray-400 text-sm mt-2" id="status-text">Loading libraries...</p>
        
        <!-- Controls for stuck loading -->
        <div id="troubleshoot-controls" class="hidden flex flex-col gap-3 mt-8 w-full max-w-xs">
            <p class="text-yellow-500 text-xs text-center">Taking longer than usual...</p>
            
            <button onclick="startApp('cpu')" class="bg-gray-700 border border-gray-600 active:bg-gray-600 text-white py-3 px-4 rounded-lg text-sm font-semibold shadow-sm">
                üõ°Ô∏è Force CPU Mode
            </button>
            
            <button onclick="location.reload()" class="bg-red-900/50 border border-red-800 text-red-200 py-3 px-4 rounded-lg text-sm shadow-sm">
                ‚Üª Reload Page
            </button>
        </div>
    </div>

    <!-- Main Viewport -->
    <div id="camera-container">
        <!-- Playsinline is critical for iOS to not force fullscreen -->
        <video id="video" playsinline muted autoplay></video>
        <canvas id="canvas"></canvas>
    </div>

    <!-- Controls -->
    <div id="ui-panel" class="hidden">
        <div class="flex flex-col gap-4">
            
            <!-- Stats & Info -->
            <div class="flex justify-between items-center text-sm font-mono text-gray-300">
                <span id="fps-counter">FPS: 0</span>
                <span id="object-count">Tracking: 0</span>
            </div>

            <!-- Vector Scale Slider -->
            <div class="w-full">
                <div class="flex justify-between mb-1">
                    <label class="text-sm font-semibold text-gray-200">Vector Scale</label>
                    <span id="scale-value" class="text-sm text-blue-400">x5</span>
                </div>
                <input type="range" id="vector-scale" min="1" max="20" value="5" step="0.5">
            </div>

            <!-- Action Buttons -->
            <div class="grid grid-cols-2 gap-4 mt-2">
                <button id="track-btn" class="bg-blue-600 active:bg-blue-700 text-white font-bold py-4 px-4 rounded-xl shadow-lg transition-transform transform active:scale-95 touch-manipulation">
                    üéØ Track Target
                </button>
                <button id="clear-btn" class="bg-red-600 active:bg-red-700 text-white font-bold py-4 px-4 rounded-xl shadow-lg transition-transform transform active:scale-95 touch-manipulation">
                    ‚ùå Clear All
                </button>
            </div>
            
            <p class="text-xs text-center text-gray-500 mt-2">
                Point at object & tap Track.
            </p>
        </div>
    </div>

<script>
/**
 * ERROR & LOGGING UTILS
 */
function log(msg) {
    console.log(msg);
    const consoleDiv = document.getElementById('debug-console');
    const p = document.createElement('div');
    p.textContent = `> ${msg}`;
    consoleDiv.appendChild(p);
    consoleDiv.scrollTop = consoleDiv.scrollHeight;
    
    // Update status text if loader is visible
    const statusText = document.getElementById('status-text');
    if (statusText) statusText.textContent = msg;
}

function handleScriptError(scriptName) {
    document.getElementById('debug-console').style.display = 'block';
    log(`CRITICAL: Failed to load ${scriptName}. Check Internet/Adblock.`);
    document.getElementById('status-title').textContent = "Load Failed";
    document.getElementById('status-text').classList.add('text-red-500');
    document.querySelector('.animate-spin').classList.add('hidden');
}

/**
 * APP STATE & CONFIGURATION
 */
const CONFIG = {
    CONFIDENCE_THRESHOLD: 0.55,
    TRACKING_DISTANCE_THRESHOLD: 150, 
    SMOOTHING_BUFFER: 8,
    LOST_TTL: 30,
};

const state = {
    model: null,
    video: document.getElementById('video'),
    canvas: document.getElementById('canvas'),
    ctx: document.getElementById('canvas').getContext('2d'),
    loader: document.getElementById('loader'),
    
    trackedObjects: [],
    nextId: 1,
    vectorScale: 5,
    isStreamReady: false,
    
    lastFrameTime: 0,
    frameCount: 0
};

// ... TrackedObject Class ...
class TrackedObject {
    constructor(id, box, label) {
        this.id = id;
        this.label = label;
        this.color = this.generateColor(id);
        this.active = true;
        this.lostFrames = 0;
        this.currentBox = box;
        this.center = this.getCenter(box);
        this.positionHistory = []; 
        this.velocity = { x: 0, y: 0 };
    }

    getCenter(box) {
        return {
            x: box[0] + box[2] / 2,
            y: box[1] + box[3] / 2
        };
    }

    generateColor(id) {
        const hue = (id * 137.508) % 360; 
        return `hsl(${hue}, 100%, 50%)`;
    }

    update(newBox) {
        this.active = true;
        this.lostFrames = 0;
        this.currentBox = newBox;
        const newCenter = this.getCenter(newBox);
        
        this.positionHistory.push({
            x: newCenter.x,
            y: newCenter.y,
            time: performance.now()
        });

        if (this.positionHistory.length > CONFIG.SMOOTHING_BUFFER) {
            this.positionHistory.shift();
        }

        this.calculateVelocity();
        this.center = newCenter;
    }

    markLost() {
        this.lostFrames++;
        if (this.lostFrames > CONFIG.LOST_TTL) {
            this.active = false;
        }
    }

    calculateVelocity() {
        if (this.positionHistory.length < 2) return;

        const newest = this.positionHistory[this.positionHistory.length - 1];
        const oldest = this.positionHistory[0];
        const dt = (newest.time - oldest.time) / 1000;
        
        if (dt === 0) return;

        const rawVx = (newest.x - oldest.x) / dt;
        const rawVy = (newest.y - oldest.y) / dt;

        this.velocity.x = rawVx;
        this.velocity.y = rawVy;
    }

    draw(ctx, scale) {
        if (!this.active) return;

        const [x, y, w, h] = this.currentBox;
        const cx = this.center.x;
        const cy = this.center.y;

        ctx.strokeStyle = this.color;
        ctx.lineWidth = 4;
        ctx.strokeRect(x, y, w, h);

        ctx.fillStyle = this.color;
        ctx.font = "bold 16px Arial";
        ctx.fillText(`#${this.id} ${this.label}`, x, y - 10);
        
        const speed = Math.sqrt(this.velocity.x**2 + this.velocity.y**2).toFixed(0);
        ctx.fillStyle = "white";
        ctx.fillText(`${speed} px/s`, x, y - 30);

        const vxEnd = cx + (this.velocity.x * scale * 0.1); 
        const vyEnd = cy + (this.velocity.y * scale * 0.1);

        this.drawArrow(ctx, cx, cy, vxEnd, cy, '#3b82f6', 4);
        this.drawArrow(ctx, cx, cy, cx, vyEnd, '#ef4444', 4);

        if (speed > 10) {
            this.drawArrow(ctx, cx, cy, vxEnd, vyEnd, '#22c55e', 2);
        }
    }

    drawArrow(ctx, fromX, fromY, toX, toY, color, width) {
        const headLength = 15; 
        const dx = toX - fromX;
        const dy = toY - fromY;
        const angle = Math.atan2(dy, dx);
        
        if (Math.sqrt(dx*dx + dy*dy) < 5) return;

        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = width;

        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(toX, toY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), toY - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), toY - headLength * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(toX, toY);
        ctx.fill();
    }
}

/**
 * STARTUP LOGIC
 */
let loadTimer;

// Auto-start with default (try WebGL)
window.onload = function() {
    // Check if scripts loaded
    if (typeof tf === 'undefined' || typeof cocoSsd === 'undefined') {
        handleScriptError("Libraries");
        return;
    }
    
    // Set a failsafe timer to show controls (Increased to 12s)
    loadTimer = setTimeout(() => {
        document.getElementById('troubleshoot-controls').classList.remove('hidden');
        log("Taking a while? Try Force CPU Mode.");
        document.getElementById('debug-console').style.display = 'block';
    }, 12000);

    // Initial attempt: WebGL
    startApp('webgl');
};

async function startApp(backendType) {
    try {
        // Reset UI if retrying
        document.getElementById('troubleshoot-controls').classList.add('hidden');
        document.querySelector('.animate-spin').classList.remove('hidden');
        
        // 1. Setup Camera
        log("Requesting Camera Access...");
        await setupCamera();
        
        // 2. Setup TF
        log(`Setting Backend: ${backendType}...`);
        await tf.ready();
        
        if (backendType === 'cpu') {
            await tf.setBackend('cpu');
        } else {
            try {
                await tf.setBackend('webgl');
                // iOS Memory Fix
                tf.env().set('WEBGL_DELETE_TEXTURE_THRESHOLD', 0);
            } catch(e) {
                log("WebGL failed. Switching to CPU.");
                await tf.setBackend('cpu');
            }
        }
        
        log(`Backend active: ${tf.getBackend()}`);

        // 3. Load Model
        log("Downloading Model...");
        state.model = await cocoSsd.load();
        
        log("Model Loaded Successfully!");
        
        // --- CRITICAL FIX START ---
        // Clear the fail-safe timer IMMEDIATELY upon success
        clearTimeout(loadTimer);
        
        // Ensure video dimensions are ready before proceeding (Fixes iOS crash)
        if (state.video.readyState < 2) {
             log("Waiting for video stream data...");
             await new Promise(r => {
                 const check = setInterval(() => {
                     if (state.video.readyState >= 2 && state.video.videoWidth > 0) {
                         clearInterval(check);
                         r();
                     }
                 }, 100);
             });
        }
        
        // Explicitly play just in case
        try { state.video.play(); } catch(e) {}

        // 4. Run UI Transition
        log("Starting Engine...");
        document.getElementById('troubleshoot-controls').classList.add('hidden'); // Double ensure hidden
        state.loader.classList.add('hidden'); // Hide overlay
        document.getElementById('ui-panel').classList.remove('hidden'); // Show controls
        document.getElementById('debug-console').style.display = 'none'; // Hide debug
        
        state.isStreamReady = true;
        resizeCanvas();
        requestAnimationFrame(gameLoop);
        // --- CRITICAL FIX END ---

    } catch (err) {
        log(`ERROR: ${err.message}`);
        document.getElementById('debug-console').style.display = 'block';
        document.querySelector('.animate-spin').classList.add('hidden');
        document.getElementById('troubleshoot-controls').classList.remove('hidden');
    }
}

async function setupCamera() {
    if (state.video.srcObject) return; // Already setup

    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            audio: false,
            video: {
                facingMode: 'environment',
                width: { ideal: 640 }, // Lower resolution for better performance/compat
                height: { ideal: 480 }
            }
        });

        state.video.srcObject = stream;
        
        return new Promise((resolve) => {
            state.video.onloadedmetadata = () => {
                log("Camera Ready");
                resolve(state.video);
            };
        });
    } catch (e) {
        throw new Error("Camera Permission Denied or Not Available");
    }
}

function resizeCanvas() {
    // Safety check for 0 dimensions
    if (state.video.videoWidth === 0 || state.video.videoHeight === 0) return;
    
    state.canvas.width = state.video.videoWidth;
    state.canvas.height = state.video.videoHeight;
}
window.addEventListener('resize', resizeCanvas);

/**
 * GAME LOOP
 */
async function gameLoop() {
    // Stats
    const now = performance.now();
    const fps = 1000 / (now - state.lastFrameTime);
    state.lastFrameTime = now;
    if (state.frameCount++ % 15 === 0) { 
        document.getElementById('fps-counter').innerText = `FPS: ${fps.toFixed(0)}`;
    }

    if (state.isStreamReady && state.model) {
        try {
            // Use detect() safely
            const predictions = await state.model.detect(state.video, undefined, CONFIG.CONFIDENCE_THRESHOLD);
            updateTracking(predictions);
            render();
        } catch (e) {
            // Don't crash loop, just log once
            if (state.frameCount % 60 === 0) console.error(e);
        }
    }

    requestAnimationFrame(gameLoop);
}

// ... updateTracking, render, and event listener functions (Unchanged) ...
function updateTracking(predictions) {
    state.trackedObjects.forEach(obj => obj.matchedThisFrame = false);
    const validPredictions = predictions.filter(p => p.score > CONFIG.CONFIDENCE_THRESHOLD);

    validPredictions.forEach(pred => {
        const predCenter = {
            x: pred.bbox[0] + pred.bbox[2] / 2,
            y: pred.bbox[1] + pred.bbox[3] / 2
        };

        let closestObj = null;
        let minDist = Infinity;

        state.trackedObjects.forEach(obj => {
            if (obj.matchedThisFrame) return;
            const dist = Math.hypot(obj.center.x - predCenter.x, obj.center.y - predCenter.y);
            if (dist < CONFIG.TRACKING_DISTANCE_THRESHOLD && dist < minDist) {
                minDist = dist;
                closestObj = obj;
            }
        });

        if (closestObj) {
            closestObj.update(pred.bbox);
            closestObj.matchedThisFrame = true;
        }
    });

    state.trackedObjects.forEach((obj) => {
        if (!obj.matchedThisFrame) obj.markLost();
    });

    state.trackedObjects = state.trackedObjects.filter(obj => obj.active);
    document.getElementById('object-count').innerText = `Tracking: ${state.trackedObjects.length}`;
}

document.getElementById('track-btn').addEventListener('click', async () => {
    const predictions = await state.model.detect(state.video, undefined, 0.3);
    
    if (predictions.length === 0) {
        alert("No objects detected.");
        return;
    }

    const screenCenterX = state.video.videoWidth / 2;
    const screenCenterY = state.video.videoHeight / 2;
    
    let closest = null;
    let minDist = Infinity;

    predictions.forEach(p => {
        const cx = p.bbox[0] + p.bbox[2]/2;
        const cy = p.bbox[1] + p.bbox[3]/2;
        const dist = Math.hypot(cx - screenCenterX, cy - screenCenterY);
        
        const alreadyTracking = state.trackedObjects.some(t => 
            Math.hypot(t.center.x - cx, t.center.y - cy) < CONFIG.TRACKING_DISTANCE_THRESHOLD
        );

        if (!alreadyTracking && dist < minDist) {
            minDist = dist;
            closest = p;
        }
    });

    if (closest) {
        state.trackedObjects.push(new TrackedObject(state.nextId++, closest.bbox, closest.class));
    }
});

document.getElementById('clear-btn').addEventListener('click', () => {
    state.trackedObjects = [];
});

document.getElementById('vector-scale').addEventListener('input', (e) => {
    state.vectorScale = parseFloat(e.target.value);
    document.getElementById('scale-value').innerText = `x${state.vectorScale}`;
});

function render() {
    const ctx = state.ctx;
    const width = state.canvas.width;
    const height = state.canvas.height;

    ctx.clearRect(0, 0, width, height);

    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(width/2 - 20, height/2);
    ctx.lineTo(width/2 + 20, height/2);
    ctx.moveTo(width/2, height/2 - 20);
    ctx.lineTo(width/2, height/2 + 20);
    ctx.stroke();

    state.trackedObjects.forEach(obj => {
        obj.draw(ctx, state.vectorScale);
    });
}
</script>
</body>
</html>
