<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Leaf Bender: Wind Master</title>
    
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- AI Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>

    <style>
        body {
            background-color: #051a05; /* Deep forest green black */
            color: white;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        video {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.3; /* Low opacity to make particles pop */
            filter: grayscale(80%) contrast(1.2); 
        }
        
        canvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
        }

        /* Loading & UI */
        .screen {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            backdrop-filter: blur(5px);
            transition: opacity 0.5s;
        }
        
        .hidden { opacity: 0; pointer-events: none; }

        .tutorial-card {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 5px;
            text-align: center;
            border: 1px solid rgba(100, 255, 100, 0.3);
            width: 140px;
        }
        .icon { font-size: 30px; margin-bottom: 5px; display: block; }
        
        #stats {
            position: absolute;
            top: 10px; right: 10px;
            font-family: monospace;
            font-size: 12px;
            color: #88ff88;
            z-index: 20;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <video id="video" playsinline muted autoplay></video>
        <canvas id="canvas"></canvas>
        
        <div id="stats">Leaves: 500 | FPS: 0</div>

        <!-- Loading Screen -->
        <div id="loading-screen" class="screen">
            <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-green-500 mb-6"></div>
            <h1 class="text-3xl font-bold text-green-400 mb-2">Summoning Leaves...</h1>
            <p class="text-gray-400">Loading AI Physics Engine</p>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="screen hidden">
            <h1 class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-emerald-600 mb-6">
                WIND MASTER
            </h1>
            
            <div class="flex flex-wrap justify-center gap-4 mb-8">
                <div class="tutorial-card">
                    <span class="icon">âœ‹</span>
                    <div class="font-bold text-green-300">OPEN PALM</div>
                    <div class="text-xs text-gray-300">Repulse / Shield</div>
                </div>
                <div class="tutorial-card">
                    <span class="icon">âœŠ</span>
                    <div class="font-bold text-green-300">CLOSED FIST</div>
                    <div class="text-xs text-gray-300">Attract / Black Hole</div>
                </div>
                <div class="tutorial-card">
                    <span class="icon">ðŸ‘‰</span>
                    <div class="font-bold text-green-300">GUN / POINT</div>
                    <div class="text-xs text-gray-300">Wind Blast</div>
                </div>
            </div>

            <button onclick="startGame()" class="bg-green-600 hover:bg-green-500 text-white font-bold py-4 px-10 rounded-full shadow-[0_0_20px_rgba(0,255,0,0.5)] transition-transform transform hover:scale-105 active:scale-95">
                ENTER THE STORM
            </button>
        </div>
    </div>

<script>
/**
 * CONFIGURATION
 */
const CONFIG = {
    PARTICLE_COUNT: 500,
    FRICTION: 0.96,
    GRAVITY: 0.08, // Weak gravity
    REPULSE_FORCE: 2.5,
    ATTRACT_FORCE: 8.0, 
    WIND_FORCE: 3.5,
    INTERACTION_RADIUS: 250,
    // Bucket Config
    BUCKET_W: 200,
    BUCKET_H: 140,
    WALL_THICK: 15
};

/**
 * STATE
 */
const state = {
    video: document.getElementById('video'),
    canvas: document.getElementById('canvas'),
    ctx: document.getElementById('canvas').getContext('2d'),
    detector: null,
    isModelReady: false,
    
    particles: [],
    hands: [], 
    
    width: 0,
    height: 0,
    lastTime: 0
};

/**
 * HELPER: Check Rectangle Collision
 */
function checkRectCollide(p, rx, ry, rw, rh) {
    return (p.x >= rx && p.x <= rx + rw && p.y >= ry && p.y <= ry + rh);
}

/**
 * PARTICLE SYSTEM
 */
class Leaf {
    constructor() {
        this.reset();
        // Scatter initially
        this.x = Math.random() * window.innerWidth;
        this.y = Math.random() * window.innerHeight;
    }

    reset() {
        this.x = Math.random() * state.width;
        this.y = -50; // Start above screen when resetting
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = Math.random() * 2;
        
        // Visuals
        this.size = Math.random() * 8 + 4;
        this.angle = Math.random() * Math.PI * 2;
        this.spin = (Math.random() - 0.5) * 0.2;
        
        // Color: Range of Greens
        const hue = 90 + Math.random() * 60; // 90 to 150 (Lime to Teal)
        const light = 30 + Math.random() * 40; // 30% to 70% lightness
        this.color = `hsla(${hue}, 80%, ${light}%, 0.8)`;
    }

    update() {
        // Apply Gravity
        this.vy += CONFIG.GRAVITY;

        // Apply Friction
        this.vx *= CONFIG.FRICTION;
        this.vy *= CONFIG.FRICTION;
        
        // Add tiny ambient float movement
        this.vx += (Math.random() - 0.5) * 0.05;

        // Position Update
        this.x += this.vx;
        this.y += this.vy;
        this.angle += this.spin;

        // --- BUCKET COLLISION ---
        const cx = state.width / 2;
        const by = state.height;
        const bw = CONFIG.BUCKET_W;
        const bh = CONFIG.BUCKET_H;
        const wt = CONFIG.WALL_THICK;

        // Left Wall Rect
        if (checkRectCollide(this, cx - bw/2 - wt, by - bh, wt, bh)) {
            if (this.vx > 0) this.vx *= -0.8; // Hitting from outside
            else this.vx *= -0.5; // Hitting from inside
            
            // Push out
            if (this.x < cx - bw/2 - wt/2) this.x = cx - bw/2 - wt - 1;
            else this.x = cx - bw/2 + 1;
        }

        // Right Wall Rect
        if (checkRectCollide(this, cx + bw/2, by - bh, wt, bh)) {
            if (this.vx < 0) this.vx *= -0.8; // Hitting from outside
            else this.vx *= -0.5; // Hitting from inside
            
            // Push out
            if (this.x > cx + bw/2 + wt/2) this.x = cx + bw/2 + wt + 1;
            else this.x = cx + bw/2 - 1;
        }

        // Floor Rect (Inside Bucket)
        if (checkRectCollide(this, cx - bw/2, by - 10, bw, 10)) {
            this.y = by - 10 - 1;
            this.vy *= -0.3; // Dampen bounce
            this.vx *= 0.8;  // Ground friction
        }

        // --- SCREEN BOUNDARIES ---
        const margin = this.size;
        
        // Walls
        if (this.x < margin) {
            this.x = margin;
            this.vx *= -1;
        }
        if (this.x > state.width - margin) {
            this.x = state.width - margin;
            this.vx *= -1;
        }
        
        // Floor (Outside Bucket)
        // If not inside bucket X range, floor is normal
        if (this.y > state.height - margin) {
             // If falling below screen
             if (Math.abs(this.x - state.width/2) > CONFIG.BUCKET_W/2 + CONFIG.WALL_THICK) {
                // Ground bounce
                this.y = state.height - margin;
                this.vy *= -0.5;
             }
        }
        
        // Ceiling (Reset if shoots up too high?) No, let gravity take it back.
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Draw Leaf Shape
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size, this.size/2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Leaf vein
        ctx.strokeStyle = "rgba(0,0,0,0.3)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-this.size, 0);
        ctx.lineTo(this.size, 0);
        ctx.stroke();
        
        ctx.restore();
    }
}

/**
 * INIT
 */
async function init() {
    try {
        await setupCamera();
        
        const model = handPoseDetection.SupportedModels.MediaPipeHands;
        const detectorConfig = {
            runtime: 'mediapipe',
            solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands',
            modelType: 'full',
            maxHands: 2
        };
        state.detector = await handPoseDetection.createDetector(model, detectorConfig);
        state.isModelReady = true;

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Initialize Particles
        for(let i=0; i<CONFIG.PARTICLE_COUNT; i++) {
            state.particles.push(new Leaf());
        }

        document.getElementById('loading-screen').classList.add('hidden');
        document.getElementById('start-screen').classList.remove('hidden');

    } catch (e) {
        alert("Camera Error: " + e.message);
    }
}

async function setupCamera() {
    const stream = await navigator.mediaDevices.getUserMedia({
        audio: false,
        video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } }
    });
    state.video.srcObject = stream;
    return new Promise(r => { state.video.onloadedmetadata = () => { state.video.play(); r(); } });
}

function resizeCanvas() {
    state.width = state.video.videoWidth;
    state.height = state.video.videoHeight;
    state.canvas.width = state.width;
    state.canvas.height = state.height;
}

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    requestAnimationFrame(loop);
}

/**
 * GESTURE LOGIC
 */
function analyzeHand(hand) {
    const k = hand.keypoints;
    const wrist = k[0];
    
    // Helper: Distance squared
    const dSq = (p1, p2) => (p1.x-p2.x)**2 + (p1.y-p2.y)**2;
    
    // Define Fingers
    const tips = [8, 12, 16, 20]; // Index, Middle, Ring, Pinky
    const pips = [6, 10, 14, 18];
    const isCurled = [false, false, false, false];
    
    // Check which fingers are curled (Tip closer to wrist than PIP)
    for(let i=0; i<4; i++) {
        if (dSq(k[tips[i]], wrist) < dSq(k[pips[i]], wrist)) {
            isCurled[i] = true;
        }
    }
    
    // 1. Check GUN / POINT (Priority 1)
    if (!isCurled[0] && isCurled[1] && isCurled[2] && isCurled[3]) {
        const dx = k[8].x - k[5].x;
        const dy = k[8].y - k[5].y;
        const len = Math.hypot(dx, dy);
        return { 
            type: 'GUN', 
            pos: k[5], 
            dir: { x: dx/len, y: dy/len } 
        };
    }

    // 2. Check FIST (Priority 2)
    if (isCurled[0] && isCurled[1] && isCurled[2] && isCurled[3]) {
        return { type: 'FIST', pos: k[9] };
    }

    // 3. Default OPEN
    return { type: 'OPEN', pos: k[9] };
}

function drawBucket(ctx) {
    const cx = state.width / 2;
    const by = state.height;
    const bw = CONFIG.BUCKET_W;
    const bh = CONFIG.BUCKET_H;
    const wt = CONFIG.WALL_THICK;

    // Metallic Gradient
    const grad = ctx.createLinearGradient(cx - bw/2, 0, cx + bw/2, 0);
    grad.addColorStop(0, '#555');
    grad.addColorStop(0.2, '#999');
    grad.addColorStop(0.5, '#eee'); // Highlight
    grad.addColorStop(0.8, '#999');
    grad.addColorStop(1, '#555');

    ctx.fillStyle = grad;
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;

    // Left Wall
    ctx.fillRect(cx - bw/2 - wt, by - bh, wt, bh);
    ctx.strokeRect(cx - bw/2 - wt, by - bh, wt, bh);

    // Right Wall
    ctx.fillRect(cx + bw/2, by - bh, wt, bh);
    ctx.strokeRect(cx + bw/2, by - bh, wt, bh);

    // Bottom
    ctx.fillRect(cx - bw/2, by - 10, bw, 10);
    
    // Label
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.font = "bold 16px Arial";
    ctx.textAlign = "center";
    ctx.fillText("LEAF BIN", cx, by - 20);
}

/**
 * MAIN LOOP
 */
async function loop() {
    const now = performance.now();
    const fps = 1000 / (now - state.lastTime);
    state.lastTime = now;
    if (Math.random() < 0.05) document.getElementById('stats').innerText = `Leaves: ${CONFIG.PARTICLE_COUNT} | FPS: ${fps.toFixed(0)}`;

    // 1. Detection
    if (state.isModelReady && state.video.readyState >= 2) {
        const handsRaw = await state.detector.estimateHands(state.video, { flipHorizontal: true });
        
        state.hands = handsRaw.map(h => analyzeHand(h));
        
        state.ctx.clearRect(0, 0, state.width, state.height);
        
        // Draw Bucket First (Behind particles? Or Front? Front makes particles appear inside)
        // Let's draw bucket back layer first if we wanted 3D, but 2D is fine.
        drawBucket(state.ctx);

        // 2. Physics Interaction
        state.particles.forEach(p => {
            state.hands.forEach(hand => {
                const dx = p.x - hand.pos.x;
                const dy = p.y - hand.pos.y;
                const distSq = dx*dx + dy*dy;
                const dist = Math.sqrt(distSq);

                if (hand.type === 'FIST') {
                    const force = CONFIG.ATTRACT_FORCE * 2000 / (distSq + 500);
                    const angle = Math.atan2(dy, dx);
                    p.vx -= Math.cos(angle) * force;
                    p.vy -= Math.sin(angle) * force;
                } 
                else if (hand.type === 'OPEN') {
                    if (dist < CONFIG.INTERACTION_RADIUS) {
                        const force = (CONFIG.INTERACTION_RADIUS - dist) / CONFIG.INTERACTION_RADIUS;
                        const angle = Math.atan2(dy, dx);
                        p.vx += Math.cos(angle) * force * CONFIG.REPULSE_FORCE;
                        p.vy += Math.sin(angle) * force * CONFIG.REPULSE_FORCE;
                    }
                }
                else if (hand.type === 'GUN') {
                    const hpx = p.x - hand.pos.x;
                    const hpy = p.y - hand.pos.y;
                    const dot = hpx * hand.dir.x + hpy * hand.dir.y;
                    
                    if (dot > 0 && dist < 800) {
                        const cross = Math.abs(hpx * hand.dir.y - hpy * hand.dir.x);
                        if (cross < 80 + dot * 0.25) { 
                            p.vx += hand.dir.x * CONFIG.WIND_FORCE;
                            p.vy += hand.dir.y * CONFIG.WIND_FORCE;
                            p.spin += 0.15; 
                        }
                    }
                }
            });

            p.update();
            p.draw(state.ctx);
        });

        // 3. Draw Hand Cursors
        state.hands.forEach(hand => {
            state.ctx.beginPath();
            state.ctx.arc(hand.pos.x, hand.pos.y, 10, 0, Math.PI*2);
            
            if (hand.type === 'FIST') {
                state.ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
                state.ctx.fill();
                state.ctx.beginPath();
                state.ctx.arc(hand.pos.x, hand.pos.y, 40, 0, Math.PI*2);
                state.ctx.strokeStyle = 'rgba(255, 50, 50, 0.5)';
                state.ctx.stroke();
            } 
            else if (hand.type === 'OPEN') {
                state.ctx.fillStyle = 'rgba(100, 255, 100, 0.8)';
                state.ctx.fill();
                state.ctx.beginPath();
                state.ctx.arc(hand.pos.x, hand.pos.y, CONFIG.INTERACTION_RADIUS / 2, 0, Math.PI*2);
                state.ctx.strokeStyle = 'rgba(100, 255, 100, 0.2)';
                state.ctx.stroke();
            }
            else if (hand.type === 'GUN') {
                state.ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                state.ctx.fill();
                state.ctx.beginPath();
                state.ctx.moveTo(hand.pos.x, hand.pos.y);
                state.ctx.lineTo(hand.pos.x + hand.dir.x * 300, hand.pos.y + hand.dir.y * 300);
                state.ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
                state.ctx.lineWidth = 4;
                state.ctx.stroke();
            }
        });
    }

    requestAnimationFrame(loop);
}

// Start
init();

</script>
</body>
</html>
